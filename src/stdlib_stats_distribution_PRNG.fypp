#:include "common.fypp"
module stdlib_stats_distribution_PRNG
    use stdlib_kinds, only: int8, int16, int32, int64
    implicit none
    private
    integer, parameter :: MAX_INT_BIT_SIZE = bit_size(1_int64)
    integer(int64), save :: st(4), si = 614872703977525537_int64
    logical, save :: seed_initialized = .false.

    public :: random_seed
    public :: dist_rand
    public :: jump
    public :: long_jump


    interface dist_rand
    !! Version experimental
    !!
    !! Generation of random integers with different kinds
    !! ([Specification](../page/specs/stdlib_stats_distribution_PRNG.html#
    !! description))
        #:for k1, t1 in INT_KINDS_TYPES
        module procedure dist_rand_${t1[0]}$${k1}$
        #:endfor
    end interface dist_rand

    interface random_seed
    !! Version experimental
    !!
    !! Set seed value for random number generator
    !! ([Specification](../page/specs/stdlib_stats_distribution_PRNG.html#
    !! description))
    !!
        #:for k1, t1 in INT_KINDS_TYPES
        module procedure random_distribution_seed_${t1[0]}$${k1}$
        #:endfor
    end interface random_seed


    contains

    #:for k1, t1 in INT_KINDS_TYPES
    function dist_rand_${t1[0]}$${k1}$(n) result(res)
    !! Random integer generation for various kinds
    !! result = [-2^k, 2^k - 1], k = 7, 15, 31, 63, depending on input kind
    !! Result is used as bit model number instead of regular arithmetic number
    !!
        ${t1}$, intent(in) :: n
        ${t1}$ :: res
        integer :: k

        k = MAX_INT_BIT_SIZE - bit_size(n)
        res = shiftr(xoshiro256ss( ), k)
    end function dist_rand_${t1[0]}$${k1}$

    #:endfor

    function xoshiro256ss( ) result (res)
    ! Generate random 64-bit integers
    ! Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)
    ! http://prng.di.unimi.it/xoshiro256starstar.c
    !
    ! This is xoshiro256** 1.0, one of our all-purpose, rock-solid
    ! generators. It has excellent (sub-ns) speed, a state (256 bits) that is
    ! large enough for any parallel application, and it passes all tests we
    ! are aware of.
    !
    ! The state must be seeded so that it is not everywhere zero. If you have
    ! a 64-bit seed, we suggest to seed a splitmix64 generator and use its
    ! output to fill st.
    !
    ! Fortran 90 version translated from C by Jim-215-Fisher
    !
        integer(int64) :: res, t

        if(.not. seed_initialized) call random_distribution_seed_iint64(si,t)
        res = rol64(st(2) * 5 , 7) * 9
        t = shiftl(st(2), 17)
        st(3) = ieor(st(3), st(1))
        st(4) = ieor(st(4), st(2))
        st(2) = ieor(st(2), st(3))
        st(1) = ieor(st(1), st(4))
        st(3) = ieor(st(3), t)
        st(4) = rol64(st(4), 45)
    end function xoshiro256ss

    function rol64(x, k) result(res)
        integer(int64), intent(in) :: x
        integer, intent(in) :: k
        integer(int64) :: t1, t2, res

        t1 = shiftr(x, (64 - k))
        t2 = shiftl(x, k)
        res = ior(t1, t2)
    end function rol64


    subroutine jump
    ! This is the jump function for the xoshiro256ss generator. It is equivalent
    ! to 2^128 calls to xoshiro256ss(); it can be used to generate 2^128
    ! non-overlapping subsequences for parallel computations.
    ! Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)
    ! http://prng.di.unimi.it/xoshiro256starstar.c
    !
    ! Fortran 90 version translated from C by Jim-215-Fisher
    integer(int64) :: jp(4) = [1733541517147835066_int64,                       &
                               -3051731464161248980_int64,                      &
                               -6244198995065845334_int64,                      &
                               4155657270789760540_int64]
    integer(int64) :: s1 = 0, s2 = 0, s3 = 0, s4 = 0, c = 1_int64
    integer :: i, j, k

    do i = 1, 4
        do j = 1, 64
            if(iand(jp(i), shiftl(c, j - 1)) /= 0) then
                s1 = ieor(s1, st(1))
                s2 = ieor(s2, st(2))
                s3 = ieor(s3, st(3))
                s4 = ieor(s4, st(4))
            end if
            k = xoshiro256ss( )
        end do
    end do
    st(1) = s1
    st(2) = s2
    st(3) = s3
    st(4) = s4
    end subroutine jump

    subroutine long_jump
    ! This is the long-jump function for the xoshiro256ss generator. It is
    ! equivalent to 2^192 calls to xoshiro256ss(); it can be used to generate
    ! 2^64 starting points, from each of which jump() will generate 2^64
    ! non-overlapping subsequences for parallel distributed computations
    ! Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)
    ! http://prng.di.unimi.it/xoshiro256starstar.c
    !
    ! Fortran 90 version translated from C by Jim-215-Fisher
    integer(int64) :: jp(4) = [8566230491382795199_int64,                       &
                               -4251311993797857357_int64,                      &
                               8606660816089834049_int64,                       &
                               4111957640723818037_int64]
    integer(int64) :: s1 = 0, s2 = 0, s3 = 0, s4 = 0, c = 1_int64
    integer(int32) :: i, j, k

    do i = 1, 4
        do j = 1, 64
            if(iand(jp(i), shiftl(c, j - 1)) /= 0) then
                s1 = ieor(s1, st(1))
                s2 = ieor(s2, st(2))
                s3 = ieor(s3, st(3))
                s4 = ieor(s4, st(4))
            end if
            k = xoshiro256ss()
        end do
    end do
    st(1) = s1
    st(2) = s2
    st(3) = s3
    st(4) = s4
    end subroutine long_jump

    function splitmix64(s) result(res)
    ! Written in 2015 by Sebastiano Vigna (vigna@acm.org)
    ! This is a fixed-increment version of Java 8's SplittableRandom
    ! generator.
    ! See http://dx.doi.org/10.1145/2714064.2660195 and
    ! http://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html
    !
    ! It is a very fast generator passing BigCrush, and it can be useful if
    ! for some reason you absolutely want 64 bits of state.
    !
    ! Fortran 90 translated from C by Jim-215-Fisher
    !
        integer(int64) :: res, int01, int02, int03
        integer(int64), intent(in), optional :: s
        data int01, int02, int03/-7046029254386353131_int64, &
                                 -4658895280553007687_int64, &
                                 -7723592293110705685_int64/

        if(present(s)) si = s
        res = si
        si = res + int01
        res = ieor(res, shiftr(res, 30)) * int02
        res = ieor(res, shiftr(res, 27)) * int03
        res = ieor(res, shiftr(res, 31))
    end function splitmix64

    #:for k1, t1 in INT_KINDS_TYPES
    subroutine random_distribution_seed_${t1[0]}$${k1}$(put, get)
    !! Set seed value for random number generator
    !!
        ${t1}$, intent(in) :: put
        ${t1}$, intent(out) :: get
        integer(int64) :: tmp
        integer :: i

        tmp = splitmix64(int(put, kind = int64))
        do i = 1, 10
            tmp = splitmix64( )
        end do
        do i = 1, 4
            tmp = splitmix64( )
            st(i) = tmp
        end do
        get = int(tmp, kind = ${k1}$)
        seed_initialized = .true.
    end subroutine random_distribution_seed_${t1[0]}$${k1}$

    #:endfor
end module stdlib_stats_distribution_PRNG
